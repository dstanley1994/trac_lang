TRAC can't support real combinators, since it doesn't have 
truely anonymous functions and creating a function is a two
step process.  But with a little creativity, you can create
something that looks an awful lot like the Y combinator, and
does the same kind of work.

Anonymous functions
-------------------
First we need to create a way to make something like an
anonymous function.  This uses an internal index to create
an "anonymous" form and return its name.  Since it returns
the name of the "anonymous" function, we can use the function
as an object to pass to other forms.

#(DS,DAS,
  (#(DS,fseq,#(AD,1,#(fseq))
  #(DS,f#(fseq),<value>)
  #(SS,f#(fseq),<args>)
  f#(fseq))
)
#(SS,DAS,<args>,<value>)

Since a non-existent form returns the empty string,
and the empty string is the same as zero, we don't
need to initialize fseq.


U Combinator
------------
The U combinator takes as an argument the name of a
form whose only argument is a form name.

#(DS,U,(#(<f>,<f>)))
#(SS,U,<f>)

Using the U combinator we can create a recursive function
from a special sort of function.  Here's an example for
calculating the factorial.

#(DS,fact,
(#(DAS,<n>,
(#(EQ,<n>,0,1,
  (#(ML,<n>,#(#(<f>,<f>),#(SU,<n>,1))))
)))))
#(SS,fct,<f>)
#(DS,!,#(#(U,fct),<n>))

Y Combinator
------------
Pass in a form that takes a
single argument and returns the name of a
form.

#(DS,Y,
  (#(#(U,
    #(DAS,<x>,
      (#(<f>,(#(U,<x>)))))))
))
#(SS,Y,<f>)

Y Combinator w/o U
------------------
Here's the closest TRAC is going to get to having a real Y combinator.


#(DS,Y,
  (#(#(DAS,<x>,(#(<f>,(#(<x>,<x>))))),#(DAS,<x>,(#(<f>,(#(<x>,<x>)))))))
))
#(SS,Y,<f>)

Here's how you would create the factorial function using the Y combinator.

#(DS,fact,
(#(DAS,<n>,
(#(EQ,<n>,0,1,
  (#(ML,<n>,#(<f>,#(SU,<n>,1))))
)))))
#(SS,fact,<f>)
#(DS,!,##(Y,fact))

Here's how you would count characters in a form using the Y combinator.

#(DS,count,
(#(DAS,<s>,
(#(EQ,#(CC,<s>,**),**,0,
  (#(AD,1,#(<f>,<s>)))
)))))
#(SS,count,<f>)
#(DS,*,##(Y,count))

