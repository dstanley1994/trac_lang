
Meta Programming

#(PS,Loading examples/meta.trl...)'

Anonymous functions
-------------------
This uses an internal index to create an "anonymous" form and return its name.
Since it returns the name of the "anonymous" function, we can use the function
as an object to pass to other scripts.

#(DS,lambda,(
  #(DS,anon_seq,#(AD,1,#(anon_seq)))
  #(DS,anon-#(anon_seq),(<value>))
  #(SS,anon-#(anon_seq),<args>)
  anon-#(anon_seq)
))
#(sss,lambda,(<args>,<value>))'

Since a non-existent form returns the empty string, and the empty string is the
same as zero, we don't need to initialize anon_seq.

Using lambda can fill your namespace with a bunch of anonymous functions that
you no longer need.  So we need some way to delete all of them.  The following
does that, and shows another way you can use lambda.  It doesn't have to be for
functions, it can also work for anonymous data.

#(DS,gc,(#(DD,anon-#(#(lambda,/,#(list-prefix,anon-,/)),(,anon-)))))


Curry
-----

Currying is to take a script that takes multiple arguments, fill in some of its
arguments and return a script that will take the rest of the necessary 
arguments and can be called at a later time.

#(DS,curry,(#(lambda,(<y>),##(CL,<f>,<x>,<y>))))
#(SS,curry,<f>,<x>)'

Usage:
(
  #(DS,func,#(curry,multi-arg-func,(a,b,c)))
  ...
  #(#(func),(some,more,args))
  
  Or another more concrete example:
  
  We need to redefine primitives to curry them:
  #(DS,mult,(#(ML,a,b)))
  #(SS,mult,a,b)
  
  Now we define something that prints an action for each number 1 through 10.
  
  #(DS,1-10,(
    #(EQ,count,10,,(
      #(PS, #(action,#(AD,1,count)))
      #(1-10,#(AD,1,count))
    ))
  ))
  #(sss,1-10,(action,count))
  
  Print ten even numbers
  #(1-10,#(curry,mult,2))
  
  Print ten multiples of five
  #(1-10,#(curry,mult,5))
)

Currying doesn't have to be that formal with TRAC.  Since TRAC is a string
language, you can define pieces of functions and then assemble them when
necessary.  In the following, we define a sum function that takes two 
lambdas, a test and a func.  

#(DS,sum,(
  #(#(test,start),total,(
    #(sum,#(AD,1,start),test,func,#(AD,total,#(func,start)))
  ))
))
#(sss,sum,(start,test,func,total))'

You see here how we would sum up all the squares from one to five.  Notice that
the first lambda is simply the first three arguments of the GR primitive.  When
it is replaced in the definition of sum above, if GR is true, the running total
if returned, otherwise sum is called again.  The GR primitive has been
effectively curried, changed into a test that takes a single argument.
(
#(sum,1,#(lambda,n,(GR,n,5)),#(lambda,n,(#(ML,n,n))))
)


Combinators
-----------

TRAC can't support real combinators, since it doesn't have truly anonymous 
functions.  But with a little creativity, you can create something that looks
an awful lot like the Y combinator, and does the same kind of work.

Of course these combinators aren't necessary for TRAC.  TRAC already supports
recursion, so there's no need to create a script that can make scripts 
recursive.  However, this does show the power of TRAC and it also helps clear
up some of the mystique of these combinators.

U Combinator
------------
The U combinator takes as an argument the name of a script whose only argument
is a script name.

#(DS,U,(#(<f>,<f>)))
#(SS,U,<f>)'

Using the U combinator we can create a recursive function from a special sort
of function.  Here's an example for calculating the factorial.

(
#(DS,fact,(
  #(lambda,<n>,(
    #(EQ,<n>,0,1,(
      #(ML,<n>,#(#(U,<f>),#(SU,<n>,1)))
    ))
  ))
))
#(sss,fact,<f>)
#(DS,!,(#(#(U,fact),<n>)))
#(SS,!,<n>)
)

How does the U combinator work?  If you turn trace on and trace through the
operation of ! you get a good idea of what's happening.  The "fact" script
creates an anonymous function which does the work of testing the end condition
and setting up the multiplication necessary. The U combinator passes a script
to itself, allowing it to call itself without direct recursion.  The doubling
in the U combinator is what makes the recursion work.  It passes a copy of the
script to be called to itself.  

The U combinator must be called inside the script that's being made recursive,
which isn't as neat as we would like.  If we factor the U combinator out of 
our script, we get the famous Y combinator.


Y Combinator
------------

This version of the Y combinator uses the U combinator in its definition.  Pass
in a script that takes a single argument and returns the name of a script.  
Looking at it this way and comparing it to the factorial definition above helps
make it understandable.  The outer U corresponds to the U in the definition of 
!, while the inner U corresponds to the U in the definition of fact.  The
definition of an anonymous function is necessary because that's the only real
way TRAC has of passing a function around as an object.  As a result this
creates a lot of identical anonymous functions.

#(DS,Y,(
  #(U,(
    #(lambda,<x>,(
      #(<f>,(#(U,<x>)))
    ))
  ))
))
#(sss,Y,<f>)'


Y Combinator w/o U
------------------

Here's the closest TRAC is going to get to having a real Y combinator.  We take
the version of Y above and expand the definition of the U combinator.  If 
you've seen the Y combinator in other forms, you will see the resemblance here.  

#(DS,Y,(
  #(lambda,<x>,(
    #(<f>,(#(<x>,<x>)))
  )),#(lambda,<x>,(
    #(<f>,(#(<x>,<x>)))
  ))
))
#(sss,Y,<f>)'

What's interesting is how the Y combinator is thought of as an airy abstraction
in computing, but here it's being defined in a language which is nothing but
strings, which is about as concrete as you can get.

Here's how you would create the factorial function using the Y combinator.  We
create a script that takes an anonymous function as an argument and returns a
new anonymous function.  The anonymous function returned takes a single integer
argument and returns one if the input was zero, otherwise multiplies the input
by the output of the script passed in.

(
#(DS,fact,(
  #(lambda,<n>,(
    #(EQ,<n>,0,1,(
      #(ML,<n>,#(<f>,#(SU,<n>,1)))
    ))
  ))
))
#(sss,fact,<f>)
#(DS,!,(#(#(Y,fact),<n>)))
#(SS,!,<n>)
)

Here's how you would count characters in a form using the Y combinator.

(
#(DS,count,(
  #(lambda,<s>,(
    #(EQ,#(CC,<s>,**),**,0,(
      #(AD,1,#(<f>,<s>))
    ))
  ))
))
#(sss,count,<f>)
#(DS,*,(#(#(Y,count),<s>)))
#(SS,*,<s>)
)

#(PS,(success!
))'
