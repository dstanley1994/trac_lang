
Scrub Whitespace
----------------
A problem with TRAC definitions is they're strings, and so if you add whitespace 
to make them readable, your definition ends up with a lot of extraneous whitespace.
Carriage return and line feed are normally ignored if they aren't protected, so they
don't need to be removed, but spaces and tabs aren't.  So here are some scripts to 
help out:

scrub-char
	scrubs a single character out of your script

	#(DS,scrub-char,(#(SS,<f>,(<c>))#(DS,<f>,##(CL,<f>))))
	#(SS,scrub-char,<f>,<c>)'

scrub
	scrubs spaces and tabs out of your script
	
	#(DS,scrub,(#(scrub-char,<f>,(	))#(scrub-char,<f>,( ))))
	#(SS,scrub,<f>)'

Call these scripts on your definitions before you call SS, otherwise your arguments 
will get messed up.  To make that easier to do:

sss	scrubs your script and then segments according to the args you pass

	#(DS,sss,(#(scrub,<f>)#(SS,<f>,<args>)))
	#(SS,sss,<f>,<args>)'

If you use this for a script that has multiple arguments, protect the argument list with
parentheses, otherwise TRAC will think your arguments are extra arguments for sss, instead
of for SS.  Remember TRAC is only passing around strings, not data structures.


Special Characters
------------------
Another problem with TRAC is that some characters are special, and so can't be used
normally.  This is especially true of the two editing characters - 
the "\" and the "@".  They can't be typed in, but since editing is not done when reading
a file, they can be entered in a file.  So here are definitions for each.

The meta character can be changed, so that a definition of the default meta character
single quote can be made.  

The hash or number sign can easily be protected by parentheses, so doesn't need a
definition at all.  However, parentheses themselves can't be defined, either at a prompt
or through a file.  

#(DS,backslash,\)'
#(DS,at,@)'
#(CM,*)'
#(DS,quote,')*
#(CM,')*

Some important characters:

#(DS,return,(
))'
#(DS,tab,	)'
#(DS,space, )'
#(DS,bell,)'
#(DS,escape,)'
#(DS,backspace,)'


Times
-----
Execute something a number of times.  The action can be a
simple string or something more complicated.

#(DS,times,(
  #(EQ,<n>,0,,(
    <action>#(times,#(SU,<n>,1),(<action>)))
  ))
)
#(sss,times,(<n>,<action>))'


Character Count
---------------
Count the number of characters in a form.  This is probably the most
involved thing that I wish was a primitive in TRAC.  There isn't a
code golf challenge that doesn't require this, and if it was a primitive
TRAC might actually have a chance.

This really counts from the form pointer to the end, and sets the form
pointer at the end of the string as a side effect.  So if you want the
real length, you have to call CR beforehand.

#(DS,count,(
  #(EQ,##(CC,<f>,--),--,<tot>,(
    #(count,<f>,#(AD,1,<tot>))
  ))
))
#(sss,count,(<f>,<tot>))'


Move To End
-----------
Move to the end of a form.  This is relatively simple, but it sure would be
nice to have a primitive that could do this, the way CR can move to the start
of a form.

#(DS,end,(
  #(EQ,##(CC,<form>,--),--,,(
    #(end,<form>)
  ))
))
#(sss,end,<form>)'


List Forms With Prefix
----------------------

One way to organize the list of defined forms is to prefix the name of related
forms with a certain value.  For instance, all the color code definitions in the
term.trl file are prefixed with "clr-".  This script allows you to list the only
those forms.  I use "-END-" as a delimiter, so if you use that as a form name
or part of a form name, this is not going to work right.

#(DS,list-prefix,(
  #(DS,names,#(LN,-END-))
  #(SS,names,-END-)
  #(DS,[list],(
    #(EQ,#(IN,names,<prefix>,-END-),-END-,,(
      #(CS,names)(<delimiter>)#([list])
    ))
  ))
  #([list])#(DD,names,[list])
))
#(sss,list-prefix,(<prefix>,<delimiter>))'
